'use server';

/**
 * SISTEMA DE CACHE INTELIGENTE PARA SUGESTÕES DE IA
 * 
 * Este serviço implementa o cache mensal das sugestões de IA seguindo as regras:
 * 1. Cache renovado automaticamente no dia 1 de cada mês
 * 2. Primeira consulta sempre gratuita (sem descontar créditos)
 * 3. Atualizações manuais consomem créditos conforme tabela
 * 4. Validação de dados suficientes antes de chamar IA
 * 5. Funciona apenas com Gastometria IA (provedor padrão)
 * 
 * TIPOS DE CACHE SUPORTADOS:
 * - spending_tip: Dicas de gastos
 * - future_balance: Previsão de saldo
 * - financial_profile: Perfil financeiro
 * - monthly_report: Relatório mensal
 * - annual_report: Relatório anual
 */

import {getDatabaseAdapter} from '@/core/services/service-factory';
import {Transaction} from '@/lib/types';
import {getActiveAICredential} from './settings-service';
import {PredictFutureBalanceOutput, FinancialProfileOutput} from '@/ai/ai-types';

export interface AICacheEntry {
  userId: string;
  type: string;
  data: any;
  generatedAt: Date;
  month: number;
  year: number;
  isAutoGenerated: boolean; // true = não consumiu créditos
}

export interface DataValidationResult {
  isValid: boolean;
  message?: string;
  requiredMinimum?: number;
  currentCount?: number;
}

/**
 * Valida se há dados suficientes para gerar sugestões
 */
export async function validateDataSufficiency(
  userId: string,
  cacheType: string,
  transactions: Transaction[] = [],
  additionalData?: any
): Promise<DataValidationResult> {
  const minimumTransactions = getMinimumTransactionsForType(cacheType);

  if (transactions.length < minimumTransactions) {
    return {
      isValid: false,
      message: `Você precisa de pelo menos ${minimumTransactions} transações para gerar esta sugestão.`,
      requiredMinimum: minimumTransactions,
      currentCount: transactions.length
    };
  }

  // Validações específicas por tipo
  switch (cacheType) {
    case 'spending_tip':
      return validateSpendingTipData(transactions);

    case 'future_balance':
      return validateFutureBalanceData(transactions, additionalData);

    case 'financial_profile':
      return validateFinancialProfileData(transactions);

    default:
      return { isValid: true };
  }
}

/**
 * Obtém cache válido ou gera novo se necessário
 */
export async function getCachedOrGenerate<T = any>(
  userId: string,
  cacheType: string,
  generateFunction: () => Promise<T>,
  forceRefresh: boolean = false
): Promise<T> {
  // Verifica se deve usar cache ou gerar novo
  if (!forceRefresh) {
    const cached = await getCachedData(userId, cacheType);
    if (cached) {
      return cached.data;
    }
  }

  // Verifica se está usando Gastometria IA
  const credential = await getActiveAICredential(userId);
  const isUsingGastometriaAI = credential.id === 'gastometria-ai-default' ||
    credential.provider === 'gastometria';

  // Gera nova sugestão
  const newData = await generateFunction();

  // Salva no cache
  await saveCacheData(userId, cacheType, newData, !forceRefresh || !isUsingGastometriaAI);

  return newData;
}

/**
 * Busca dados em cache válido para o mês atual
 */
export async function getCachedData(userId: string, cacheType: string): Promise<AICacheEntry | null> {
  const db = await getDatabaseAdapter();
  const now = new Date();
  const currentMonth = now.getMonth() + 1;
  const currentYear = now.getFullYear();

  const cached = await db.aiGeneratedData.findByUserIdAndType(userId, cacheType);

  if (!cached) {
    return null;
  }

  // Verifica se é do mês atual
  const cachedMonth = cached.month || 0;
  const cachedYear = cached.year || 0;

  if (cachedMonth === currentMonth && cachedYear === currentYear) {
    return {
      userId: cached.userId,
      type: cached.type,
      data: cached.data,
      generatedAt: cached.generatedAt,
      month: cachedMonth,
      year: cachedYear,
      isAutoGenerated: cached.isAutoGenerated || false
    };
  }

  return null;
}

/**
 * Salva dados no cache
 */
export async function saveCacheData(
  userId: string,
  cacheType: string,
  data: any,
  isAutoGenerated: boolean = true
): Promise<void> {
  const db = await getDatabaseAdapter();
  const now = new Date();
  const currentMonth = now.getMonth() + 1;
  const currentYear = now.getFullYear();

  const cacheData = {
    userId,
    type: cacheType,
    data,
    generatedAt: now,
    month: currentMonth,
    year: currentYear,
    isAutoGenerated
  };

  // Substitui dados existentes do mês atual
  await db.aiGeneratedData.replaceByUserIdAndType(userId, cacheType, cacheData);
}

/**
 * Verifica se deve gerar cache automaticamente (primeira vez ou início do mês)
 */
export async function shouldAutoGenerateCache(userId: string, cacheType: string): Promise<boolean> {
  const cached = await getCachedData(userId, cacheType);

  // Se não há cache, deve gerar
  if (!cached) {
    return true;
  }

  // Se é início do mês (dia 1-3) e ainda não foi gerado este mês, deve gerar
  const now = new Date();
  const dayOfMonth = now.getDate();
  const currentMonth = now.getMonth() + 1;
  const currentYear = now.getFullYear();

  if (dayOfMonth <= 3 &&
    (cached.month !== currentMonth || cached.year !== currentYear)) {
    return true;
  }

  return false;
}

/**
 * Limpa caches antigos (manter apenas últimos 3 meses)
 */
export async function cleanupOldCache(): Promise<void> {
  const db = await getDatabaseAdapter();
  const threeMonthsAgo = new Date();
  threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);

  await db.aiGeneratedData.deleteOldData(threeMonthsAgo);
  console.log('[AI Cache] Cleaned up old cache data');
}

// ========== VALIDAÇÕES ESPECÍFICAS ==========

function getMinimumTransactionsForType(cacheType: string): number {
  switch (cacheType) {
    case 'spending_tip':
      return 5;
    case 'future_balance':
      return 10;
    case 'financial_profile':
      return 15;
    case 'monthly_report':
      return 8;
    case 'annual_report':
      return 20;
    default:
      return 3;
  }
}

function validateSpendingTipData(transactions: Transaction[]): DataValidationResult {
  const expenseTransactions = transactions.filter(t => t.type === 'expense');

  if (expenseTransactions.length < 3) {
    return {
      isValid: false,
      message: 'Você precisa de pelo menos 3 transações de despesa para receber dicas personalizadas.',
      requiredMinimum: 3,
      currentCount: expenseTransactions.length
    };
  }

  // Verifica se há categorias suficientes
  const categories = new Set(expenseTransactions.map(t => t.category));
  if (categories.size < 2) {
    return {
      isValid: false,
      message: 'Adicione transações de diferentes categorias para receber dicas mais precisas.',
      requiredMinimum: 2,
      currentCount: categories.size
    };
  }

  return { isValid: true };
}

function validateFutureBalanceData(transactions: Transaction[], additionalData?: any): DataValidationResult {
  const lastMonthTransactions = getLastMonthTransactions(transactions);

  if (lastMonthTransactions.length < 5) {
    return {
      isValid: false,
      message: 'Você precisa de pelo menos 5 transações do último mês para uma previsão confiável.',
      requiredMinimum: 5,
      currentCount: lastMonthTransactions.length
    };
  }

  const expenseTransactions = lastMonthTransactions.filter(t => t.type === 'expense');
  if (expenseTransactions.length < 3) {
    return {
      isValid: false,
      message: 'Você precisa de pelo menos 3 despesas no último mês para previsão de saldo.',
      requiredMinimum: 3,
      currentCount: expenseTransactions.length
    };
  }

  return { isValid: true };
}

function validateFinancialProfileData(transactions: Transaction[]): DataValidationResult {
  const lastThreeMonths = getLastThreeMonthsTransactions(transactions);

  if (lastThreeMonths.length < 10) {
    return {
      isValid: false,
      message: 'Você precisa de pelo menos 10 transações dos últimos 3 meses para um perfil financeiro completo.',
      requiredMinimum: 10,
      currentCount: lastThreeMonths.length
    };
  }

  const incomeTransactions = lastThreeMonths.filter(t => t.type === 'income');
  const expenseTransactions = lastThreeMonths.filter(t => t.type === 'expense');

  if (incomeTransactions.length === 0) {
    return {
      isValid: false,
      message: 'Adicione pelo menos uma receita para gerar seu perfil financeiro.',
      requiredMinimum: 1,
      currentCount: 0
    };
  }

  if (expenseTransactions.length < 5) {
    return {
      isValid: false,
      message: 'Você precisa de pelo menos 5 despesas nos últimos 3 meses.',
      requiredMinimum: 5,
      currentCount: expenseTransactions.length
    };
  }

  return { isValid: true };
}

// ========== UTILITÁRIOS ==========

function getLastMonthTransactions(transactions: Transaction[]): Transaction[] {
  const now = new Date();
  const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
  const endLastMonth = new Date(now.getFullYear(), now.getMonth(), 0);

  return transactions.filter(t => {
    const transactionDate = new Date(t.date);
    return transactionDate >= lastMonth && transactionDate <= endLastMonth;
  });
}

function getLastThreeMonthsTransactions(transactions: Transaction[]): Transaction[] {
  const now = new Date();
  const threeMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 3, 1);

  return transactions.filter(t => new Date(t.date) >= threeMonthsAgo);
}