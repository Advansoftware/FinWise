// src/services/smart-transactions-service.ts
// Serviço de Transações Inteligentes - Core Logic

import { connectToDatabase } from '@/lib/mongodb';
import { ObjectId } from 'mongodb';
import { Transaction, TransactionCategory } from '@/lib/types';
import {
  MerchantRule,
  MerchantRuleMatch,
  DetectedRecurrence,
  RecurrenceFrequency,
  CategorySuggestion,
  WalletSuggestion,
  TransactionSuggestions,
  TransactionAnomaly,
  AnomalyType,
  SmartLearningData,
  BulkActionResult,
} from '@/lib/smart-transactions-types';

// ==================== MERCHANT RULES ====================

export class SmartTransactionsService {

  /**
   * Normaliza texto para matching (lowercase, remove acentos, espaços extras)
   */
  static normalizeText(text: string): string {
    return text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remove acentos
      .replace(/[^a-z0-9\s]/g, '') // Remove caracteres especiais
      .replace(/\s+/g, ' ') // Normaliza espaços
      .trim();
  }

  /**
   * Extrai palavras-chave do nome do item/estabelecimento
   */
  static extractKeywords(text: string): string[] {
    const normalized = this.normalizeText(text);
    const words = normalized.split(' ');

    // Filtra palavras muito curtas ou comuns
    const stopWords = ['de', 'da', 'do', 'das', 'dos', 'em', 'para', 'com', 'por', 'ao', 'a', 'o', 'e', 'pix', 'ted', 'doc', 'compra', 'pagamento', 'debito', 'credito'];

    return words.filter(w => w.length > 2 && !stopWords.includes(w));
  }

  /**
   * Gera padrões de matching a partir de um nome de estabelecimento
   */
  static generatePatterns(merchantName: string): string[] {
    const normalized = this.normalizeText(merchantName);
    const keywords = this.extractKeywords(merchantName);

    const patterns: string[] = [normalized];

    // Adiciona keywords individuais se forem significativas
    keywords.forEach(kw => {
      if (kw.length >= 4) {
        patterns.push(kw);
      }
    });

    // Adiciona combinações de keywords adjacentes
    for (let i = 0; i < keywords.length - 1; i++) {
      patterns.push(`${keywords[i]} ${keywords[i + 1]}`);
    }

    return [...new Set(patterns)]; // Remove duplicatas
  }

  /**
   * Verifica se um texto faz match com uma regra
   */
  static matchesRule(text: string, rule: MerchantRule): MerchantRuleMatch | null {
    const normalized = this.normalizeText(text);

    for (const pattern of rule.merchantPatterns) {
      // Match exato
      if (normalized === pattern) {
        return { rule, confidence: 1.0, matchedPattern: pattern };
      }

      // Match contido
      if (normalized.includes(pattern) || pattern.includes(normalized)) {
        const shorter = Math.min(normalized.length, pattern.length);
        const longer = Math.max(normalized.length, pattern.length);
        const confidence = shorter / longer;

        if (confidence > 0.5) {
          return { rule, confidence, matchedPattern: pattern };
        }
      }

      // Match por palavras-chave
      const textKeywords = this.extractKeywords(text);
      const patternKeywords = this.extractKeywords(pattern);

      if (patternKeywords.length > 0) {
        const matchingKeywords = patternKeywords.filter(pk =>
          textKeywords.some(tk => tk.includes(pk) || pk.includes(tk))
        );

        const confidence = matchingKeywords.length / patternKeywords.length;
        if (confidence > 0.6) {
          return { rule, confidence, matchedPattern: pattern };
        }
      }
    }

    return null;
  }

  /**
   * Encontra a melhor regra para um texto
   */
  static async findBestMatchingRule(
    userId: string,
    itemOrEstablishment: string
  ): Promise<MerchantRuleMatch | null> {
    const { db } = await connectToDatabase();

    const rules = await db.collection<MerchantRule>('merchantRules')
      .find({ userId, isActive: true })
      .toArray();

    let bestMatch: MerchantRuleMatch | null = null;

    for (const rule of rules) {
      const match = this.matchesRule(itemOrEstablishment, rule as unknown as MerchantRule);

      if (match && (!bestMatch || match.confidence > bestMatch.confidence)) {
        bestMatch = match;
      }
    }

    return bestMatch;
  }

  /**
   * Cria uma nova regra de merchant
   */
  static async createMerchantRule(
    userId: string,
    data: {
      merchantName: string;
      merchantPatterns?: string[];
      defaultCategory: TransactionCategory;
      defaultSubcategory?: string;
      defaultWalletId?: string;
      defaultType?: 'income' | 'expense';
      isAutoGenerated?: boolean;
    }
  ): Promise<MerchantRule> {
    const { db } = await connectToDatabase();

    const patterns = data.merchantPatterns || this.generatePatterns(data.merchantName);

    const rule: Omit<MerchantRule, 'id'> = {
      userId,
      merchantName: data.merchantName,
      merchantPatterns: patterns,
      defaultCategory: data.defaultCategory,
      defaultSubcategory: data.defaultSubcategory,
      defaultWalletId: data.defaultWalletId,
      defaultType: data.defaultType,
      matchCount: 0,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      isAutoGenerated: data.isAutoGenerated || false,
      isActive: true,
    };

    const result = await db.collection('merchantRules').insertOne(rule);

    return {
      ...rule,
      id: result.insertedId.toString(),
    };
  }

  /**
   * Atualiza uma regra existente
   */
  static async updateMerchantRule(
    userId: string,
    ruleId: string,
    updates: Partial<MerchantRule>
  ): Promise<boolean> {
    const { db } = await connectToDatabase();

    const result = await db.collection('merchantRules').updateOne(
      { _id: new ObjectId(ruleId), userId },
      {
        $set: {
          ...updates,
          updatedAt: new Date().toISOString()
        }
      }
    );

    return result.modifiedCount > 0;
  }

  /**
   * Incrementa contador de uso da regra
   */
  static async incrementRuleMatchCount(ruleId: string): Promise<void> {
    const { db } = await connectToDatabase();

    await db.collection('merchantRules').updateOne(
      { _id: new ObjectId(ruleId) },
      {
        $inc: { matchCount: 1 },
        $set: { lastMatchedAt: new Date().toISOString() }
      }
    );
  }

  /**
   * Lista todas as regras do usuário
   */
  static async getMerchantRules(userId: string): Promise<MerchantRule[]> {
    const { db } = await connectToDatabase();

    const rules = await db.collection('merchantRules')
      .find({ userId })
      .sort({ matchCount: -1 })
      .toArray();

    return rules.map(r => ({
      ...r,
      id: r._id.toString(),
      _id: undefined,
    })) as unknown as MerchantRule[];
  }

  /**
   * Deleta uma regra
   */
  static async deleteMerchantRule(userId: string, ruleId: string): Promise<boolean> {
    const { db } = await connectToDatabase();

    const result = await db.collection('merchantRules').deleteOne({
      _id: new ObjectId(ruleId),
      userId,
    });

    return result.deletedCount > 0;
  }

  // ==================== RECURRENCE DETECTION ====================

  /**
   * Detecta transações recorrentes para um usuário
   */
  static async detectRecurrences(userId: string): Promise<DetectedRecurrence[]> {
    const { db } = await connectToDatabase();

    // Busca transações dos últimos 6 meses
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

    const transactions = await db.collection<Transaction>('transactions')
      .find({
        userId,
        date: { $gte: sixMonthsAgo.toISOString() },
      })
      .sort({ date: 1 })
      .toArray();

    // Agrupa por padrão de nome (normalizado)
    const groups = new Map<string, Transaction[]>();

    for (const tx of transactions) {
      const key = this.normalizeText(tx.item || tx.establishment || '');
      if (!key || key.length < 3) continue;

      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(tx as unknown as Transaction);
    }

    const recurrences: DetectedRecurrence[] = [];

    for (const [pattern, txs] of groups) {
      // Precisa de pelo menos 3 ocorrências para detectar recorrência
      if (txs.length < 3) continue;

      const frequency = this.detectFrequency(txs);
      if (!frequency) continue;

      const amounts = txs.map(t => t.amount);
      const avgAmount = amounts.reduce((a, b) => a + b, 0) / amounts.length;
      const minAmount = Math.min(...amounts);
      const maxAmount = Math.max(...amounts);
      const variation = ((maxAmount - minAmount) / avgAmount) * 100;

      // Variação de até 20% é aceitável para recorrência
      if (variation > 20) continue;

      const lastTx = txs[txs.length - 1];

      recurrences.push({
        id: `rec_${pattern.slice(0, 10)}_${Date.now()}`,
        userId,
        pattern,
        merchantName: lastTx.establishment || lastTx.item,
        frequency,
        averageAmount: Math.round(avgAmount * 100) / 100,
        amountVariation: Math.round(variation * 100) / 100,
        lastOccurrence: lastTx.date,
        nextExpectedDate: this.calculateNextDate(lastTx.date, frequency),
        occurrences: txs.length,
        transactionIds: txs.map(t => t.id),
        category: lastTx.category,
        subcategory: lastTx.subcategory,
        type: lastTx.type as 'income' | 'expense',
        isConfirmed: false,
        isActive: true,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });
    }

    return recurrences.sort((a, b) => b.occurrences - a.occurrences);
  }

  /**
   * Detecta a frequência de uma série de transações
   */
  static detectFrequency(transactions: Transaction[]): RecurrenceFrequency | null {
    if (transactions.length < 2) return null;

    const dates = transactions
      .map(t => new Date(t.date).getTime())
      .sort((a, b) => a - b);

    const gaps: number[] = [];
    for (let i = 1; i < dates.length; i++) {
      gaps.push(dates[i] - dates[i - 1]);
    }

    // Calcula gap médio em dias
    const avgGapMs = gaps.reduce((a, b) => a + b, 0) / gaps.length;
    const avgGapDays = avgGapMs / (1000 * 60 * 60 * 24);

    // Determina frequência baseado no gap médio
    if (avgGapDays <= 2) return 'daily';
    if (avgGapDays >= 6 && avgGapDays <= 8) return 'weekly';
    if (avgGapDays >= 13 && avgGapDays <= 16) return 'biweekly';
    if (avgGapDays >= 28 && avgGapDays <= 32) return 'monthly';
    if (avgGapDays >= 58 && avgGapDays <= 64) return 'bimonthly';
    if (avgGapDays >= 88 && avgGapDays <= 95) return 'quarterly';
    if (avgGapDays >= 175 && avgGapDays <= 190) return 'semiannual';
    if (avgGapDays >= 360 && avgGapDays <= 370) return 'annual';

    return null;
  }

  /**
   * Calcula próxima data esperada baseado na frequência
   */
  static calculateNextDate(lastDate: string, frequency: RecurrenceFrequency): string {
    const date = new Date(lastDate);

    switch (frequency) {
      case 'daily':
        date.setDate(date.getDate() + 1);
        break;
      case 'weekly':
        date.setDate(date.getDate() + 7);
        break;
      case 'biweekly':
        date.setDate(date.getDate() + 14);
        break;
      case 'monthly':
        date.setMonth(date.getMonth() + 1);
        break;
      case 'bimonthly':
        date.setMonth(date.getMonth() + 2);
        break;
      case 'quarterly':
        date.setMonth(date.getMonth() + 3);
        break;
      case 'semiannual':
        date.setMonth(date.getMonth() + 6);
        break;
      case 'annual':
        date.setFullYear(date.getFullYear() + 1);
        break;
    }

    return date.toISOString();
  }

  // ==================== SMART SUGGESTIONS ====================

  /**
   * Gera sugestões inteligentes para uma transação
   */
  static async getSuggestions(
    userId: string,
    item: string,
    establishment?: string,
    amount?: number
  ): Promise<TransactionSuggestions> {
    const searchText = establishment || item;
    const suggestions: TransactionSuggestions = {
      categories: [],
      wallets: [],
    };

    // 1. Verifica regras de merchant
    const ruleMatch = await this.findBestMatchingRule(userId, searchText);
    if (ruleMatch && ruleMatch.confidence > 0.7) {
      suggestions.merchantRule = ruleMatch.rule;

      suggestions.categories.push({
        category: ruleMatch.rule.defaultCategory,
        subcategory: ruleMatch.rule.defaultSubcategory,
        confidence: ruleMatch.confidence,
        source: 'merchant_rule',
        reason: `Baseado em "${ruleMatch.rule.merchantName}"`,
      });

      if (ruleMatch.rule.defaultWalletId) {
        suggestions.wallets.push({
          walletId: ruleMatch.rule.defaultWalletId,
          walletName: '', // Será preenchido pelo frontend
          confidence: ruleMatch.confidence,
          source: 'merchant_rule',
          reason: `Carteira padrão para "${ruleMatch.rule.merchantName}"`,
        });
      }
    }

    // 2. Verifica histórico de transações similares
    const historySuggestions = await this.getSuggestionsFromHistory(userId, searchText);
    suggestions.categories.push(...historySuggestions.categories);
    suggestions.wallets.push(...historySuggestions.wallets);

    // 3. Sugestões por palavras-chave
    const keywordSuggestions = this.getSuggestionsFromKeywords(item);
    suggestions.categories.push(...keywordSuggestions);

    // Remove duplicatas e ordena por confiança
    suggestions.categories = this.deduplicateSuggestions(suggestions.categories);
    suggestions.wallets = this.deduplicateWalletSuggestions(suggestions.wallets);

    return suggestions;
  }

  /**
   * Busca sugestões baseadas no histórico de transações
   */
  static async getSuggestionsFromHistory(
    userId: string,
    searchText: string
  ): Promise<{ categories: CategorySuggestion[]; wallets: WalletSuggestion[] }> {
    const { db } = await connectToDatabase();

    const normalized = this.normalizeText(searchText);
    const keywords = this.extractKeywords(searchText);

    if (keywords.length === 0) {
      return { categories: [], wallets: [] };
    }

    // Busca transações com termos similares
    const regexPatterns = keywords.map(kw => new RegExp(kw, 'i'));

    const similarTransactions = await db.collection<Transaction>('transactions')
      .find({
        userId,
        $or: [
          { item: { $in: regexPatterns } },
          { establishment: { $in: regexPatterns } },
        ],
      })
      .limit(50)
      .toArray();

    if (similarTransactions.length === 0) {
      return { categories: [], wallets: [] };
    }

    // Conta categorias
    const categoryCounts = new Map<TransactionCategory, number>();
    const walletCounts = new Map<string, number>();

    for (const tx of similarTransactions) {
      const cat = tx.category;
      categoryCounts.set(cat, (categoryCounts.get(cat) || 0) + 1);

      const wallet = tx.walletId;
      walletCounts.set(wallet, (walletCounts.get(wallet) || 0) + 1);
    }

    const total = similarTransactions.length;
    const categories: CategorySuggestion[] = [];
    const wallets: WalletSuggestion[] = [];

    // Converte para sugestões
    for (const [category, count] of categoryCounts) {
      const confidence = count / total;
      if (confidence > 0.3) { // Pelo menos 30% das transações
        categories.push({
          category,
          confidence: Math.min(confidence, 0.9), // Cap em 0.9 para histórico
          source: 'history_pattern',
          reason: `${count} transações similares usam esta categoria`,
        });
      }
    }

    for (const [walletId, count] of walletCounts) {
      const confidence = count / total;
      if (confidence > 0.3) {
        wallets.push({
          walletId,
          walletName: '',
          confidence: Math.min(confidence, 0.9),
          source: 'history_pattern',
          reason: `${count} transações similares usam esta carteira`,
        });
      }
    }

    return { categories, wallets };
  }

  /**
   * Sugestões baseadas em palavras-chave conhecidas
   */
  static getSuggestionsFromKeywords(text: string): CategorySuggestion[] {
    const normalized = this.normalizeText(text);
    const suggestions: CategorySuggestion[] = [];

    // Mapeamento de palavras-chave para categorias
    const keywordMap: Record<string, { category: TransactionCategory; confidence: number }> = {
      // Supermercado
      'carrefour': { category: 'Supermercado', confidence: 0.95 },
      'extra': { category: 'Supermercado', confidence: 0.8 },
      'atacadao': { category: 'Supermercado', confidence: 0.95 },
      'assai': { category: 'Supermercado', confidence: 0.95 },
      'pao de acucar': { category: 'Supermercado', confidence: 0.95 },
      'mercado': { category: 'Supermercado', confidence: 0.7 },
      'supermercado': { category: 'Supermercado', confidence: 0.95 },

      // Restaurante
      'ifood': { category: 'Restaurante', confidence: 0.9 },
      'rappi': { category: 'Restaurante', confidence: 0.9 },
      'uber eats': { category: 'Restaurante', confidence: 0.9 },
      'restaurante': { category: 'Restaurante', confidence: 0.9 },
      'lanchonete': { category: 'Restaurante', confidence: 0.85 },
      'pizzaria': { category: 'Restaurante', confidence: 0.9 },
      'hamburguer': { category: 'Restaurante', confidence: 0.85 },
      'mcdonalds': { category: 'Restaurante', confidence: 0.95 },
      'burger king': { category: 'Restaurante', confidence: 0.95 },
      'subway': { category: 'Restaurante', confidence: 0.95 },
      'starbucks': { category: 'Restaurante', confidence: 0.9 },

      // Transporte
      'uber': { category: 'Transporte', confidence: 0.9 },
      '99': { category: 'Transporte', confidence: 0.85 },
      '99app': { category: 'Transporte', confidence: 0.9 },
      'posto': { category: 'Transporte', confidence: 0.8 },
      'combustivel': { category: 'Transporte', confidence: 0.9 },
      'gasolina': { category: 'Transporte', confidence: 0.95 },
      'etanol': { category: 'Transporte', confidence: 0.95 },
      'estacionamento': { category: 'Transporte', confidence: 0.9 },
      'pedagio': { category: 'Transporte', confidence: 0.95 },
      'ipva': { category: 'Transporte', confidence: 0.95 },

      // Entretenimento
      'netflix': { category: 'Entretenimento', confidence: 0.95 },
      'spotify': { category: 'Entretenimento', confidence: 0.95 },
      'amazon prime': { category: 'Entretenimento', confidence: 0.95 },
      'disney': { category: 'Entretenimento', confidence: 0.95 },
      'hbo': { category: 'Entretenimento', confidence: 0.95 },
      'cinema': { category: 'Entretenimento', confidence: 0.9 },
      'ingresso': { category: 'Entretenimento', confidence: 0.75 },
      'show': { category: 'Entretenimento', confidence: 0.7 },
      'youtube': { category: 'Entretenimento', confidence: 0.9 },
      'twitch': { category: 'Entretenimento', confidence: 0.9 },
      'playstation': { category: 'Entretenimento', confidence: 0.9 },
      'xbox': { category: 'Entretenimento', confidence: 0.9 },
      'steam': { category: 'Entretenimento', confidence: 0.9 },

      // Contas
      'luz': { category: 'Contas', confidence: 0.85 },
      'energia': { category: 'Contas', confidence: 0.85 },
      'enel': { category: 'Contas', confidence: 0.95 },
      'cemig': { category: 'Contas', confidence: 0.95 },
      'copel': { category: 'Contas', confidence: 0.95 },
      'agua': { category: 'Contas', confidence: 0.85 },
      'sabesp': { category: 'Contas', confidence: 0.95 },
      'sanepar': { category: 'Contas', confidence: 0.95 },
      'gas': { category: 'Contas', confidence: 0.8 },
      'internet': { category: 'Contas', confidence: 0.9 },
      'telefone': { category: 'Contas', confidence: 0.85 },
      'celular': { category: 'Contas', confidence: 0.8 },
      'vivo': { category: 'Contas', confidence: 0.85 },
      'claro': { category: 'Contas', confidence: 0.85 },
      'tim': { category: 'Contas', confidence: 0.85 },
      'oi': { category: 'Contas', confidence: 0.7 },
      'aluguel': { category: 'Contas', confidence: 0.95 },
      'condominio': { category: 'Contas', confidence: 0.95 },
      'iptu': { category: 'Contas', confidence: 0.95 },

      // Saúde
      'farmacia': { category: 'Saúde', confidence: 0.9 },
      'drogaria': { category: 'Saúde', confidence: 0.9 },
      'droga raia': { category: 'Saúde', confidence: 0.95 },
      'drogasil': { category: 'Saúde', confidence: 0.95 },
      'pacheco': { category: 'Saúde', confidence: 0.9 },
      'hospital': { category: 'Saúde', confidence: 0.95 },
      'clinica': { category: 'Saúde', confidence: 0.85 },
      'medico': { category: 'Saúde', confidence: 0.9 },
      'consulta': { category: 'Saúde', confidence: 0.85 },
      'exame': { category: 'Saúde', confidence: 0.85 },
      'plano de saude': { category: 'Saúde', confidence: 0.95 },
      'unimed': { category: 'Saúde', confidence: 0.95 },
      'amil': { category: 'Saúde', confidence: 0.95 },
      'bradesco saude': { category: 'Saúde', confidence: 0.95 },

      // Educação
      'escola': { category: 'Educação', confidence: 0.9 },
      'faculdade': { category: 'Educação', confidence: 0.95 },
      'universidade': { category: 'Educação', confidence: 0.95 },
      'curso': { category: 'Educação', confidence: 0.8 },
      'livro': { category: 'Educação', confidence: 0.75 },
      'udemy': { category: 'Educação', confidence: 0.9 },
      'alura': { category: 'Educação', confidence: 0.95 },
      'rocketseat': { category: 'Educação', confidence: 0.95 },
      'duolingo': { category: 'Educação', confidence: 0.9 },
      'mensalidade': { category: 'Educação', confidence: 0.7 },

      // Vestuário
      'renner': { category: 'Vestuário', confidence: 0.95 },
      'riachuelo': { category: 'Vestuário', confidence: 0.95 },
      'cea': { category: 'Vestuário', confidence: 0.9 },
      'marisa': { category: 'Vestuário', confidence: 0.95 },
      'zara': { category: 'Vestuário', confidence: 0.95 },
      'hm': { category: 'Vestuário', confidence: 0.9 },
      'roupa': { category: 'Vestuário', confidence: 0.85 },
      'calcado': { category: 'Vestuário', confidence: 0.85 },
      'tenis': { category: 'Vestuário', confidence: 0.7 },
      'centauro': { category: 'Vestuário', confidence: 0.9 },
      'netshoes': { category: 'Vestuário', confidence: 0.9 },

      // Investimentos
      'investimento': { category: 'Investimentos', confidence: 0.9 },
      'tesouro': { category: 'Investimentos', confidence: 0.9 },
      'cdb': { category: 'Investimentos', confidence: 0.9 },
      'acoes': { category: 'Investimentos', confidence: 0.85 },
      'fundo': { category: 'Investimentos', confidence: 0.75 },
      'nuinvest': { category: 'Investimentos', confidence: 0.95 },
      'xp': { category: 'Investimentos', confidence: 0.8 },
      'rico': { category: 'Investimentos', confidence: 0.8 },

      // Salário
      'salario': { category: 'Salário', confidence: 0.95 },
      'pagamento': { category: 'Salário', confidence: 0.6 },
      'deposito': { category: 'Salário', confidence: 0.5 },
      'holerite': { category: 'Salário', confidence: 0.95 },
      '13o': { category: 'Salário', confidence: 0.9 },
      'ferias': { category: 'Salário', confidence: 0.8 },
      'pis': { category: 'Salário', confidence: 0.9 },
      'fgts': { category: 'Salário', confidence: 0.9 },
    };

    for (const [keyword, config] of Object.entries(keywordMap)) {
      if (normalized.includes(keyword)) {
        suggestions.push({
          category: config.category,
          confidence: config.confidence * 0.85, // Reduce um pouco por ser keyword genérica
          source: 'keyword_match',
          reason: `Contém "${keyword}"`,
        });
      }
    }

    return suggestions;
  }

  /**
   * Remove sugestões duplicadas, mantendo a de maior confiança
   */
  static deduplicateSuggestions(suggestions: CategorySuggestion[]): CategorySuggestion[] {
    const map = new Map<TransactionCategory, CategorySuggestion>();

    for (const suggestion of suggestions) {
      const existing = map.get(suggestion.category);
      if (!existing || suggestion.confidence > existing.confidence) {
        map.set(suggestion.category, suggestion);
      }
    }

    return Array.from(map.values())
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 3); // Top 3
  }

  /**
   * Remove sugestões de carteira duplicadas
   */
  static deduplicateWalletSuggestions(suggestions: WalletSuggestion[]): WalletSuggestion[] {
    const map = new Map<string, WalletSuggestion>();

    for (const suggestion of suggestions) {
      const existing = map.get(suggestion.walletId);
      if (!existing || suggestion.confidence > existing.confidence) {
        map.set(suggestion.walletId, suggestion);
      }
    }

    return Array.from(map.values())
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 2); // Top 2
  }

  // ==================== ANOMALY DETECTION ====================

  /**
   * Detecta anomalias nas transações do usuário
   */
  static async detectAnomalies(userId: string): Promise<TransactionAnomaly[]> {
    const { db } = await connectToDatabase();

    const anomalies: TransactionAnomaly[] = [];

    // Busca transações recentes
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const recentTransactions = await db.collection<Transaction>('transactions')
      .find({
        userId,
        date: { $gte: thirtyDaysAgo.toISOString() },
      })
      .toArray();

    // 1. Detecta duplicatas
    const duplicates = this.findDuplicates(recentTransactions as unknown as Transaction[]);
    for (const dup of duplicates) {
      anomalies.push({
        id: `anomaly_dup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        userId,
        type: 'duplicate',
        severity: 'medium',
        transactionId: dup.transactionIds[0],
        relatedTransactionIds: dup.transactionIds.slice(1),
        title: 'Possível transação duplicada',
        description: `Encontramos ${dup.transactionIds.length} transações muito similares para "${dup.item}" no valor de R$ ${dup.amount.toFixed(2)}`,
        isResolved: false,
        createdAt: new Date().toISOString(),
      });
    }

    // 2. Detecta valores incomuns por categoria
    const unusualAmounts = await this.findUnusualAmounts(userId, recentTransactions as unknown as Transaction[]);
    for (const unusual of unusualAmounts) {
      anomalies.push({
        id: `anomaly_amt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        userId,
        type: 'unusual_amount',
        severity: unusual.severity,
        transactionId: unusual.transactionId,
        title: 'Valor incomum detectado',
        description: unusual.description,
        isResolved: false,
        createdAt: new Date().toISOString(),
      });
    }

    return anomalies;
  }

  /**
   * Encontra transações duplicadas
   */
  static findDuplicates(transactions: Transaction[]): { item: string; amount: number; transactionIds: string[] }[] {
    const duplicates: { item: string; amount: number; transactionIds: string[] }[] = [];

    // Agrupa por data + valor + item similar
    const groups = new Map<string, Transaction[]>();

    for (const tx of transactions) {
      const dateKey = tx.date.split('T')[0]; // Apenas a data
      const key = `${dateKey}_${tx.amount}_${this.normalizeText(tx.item)}`;

      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(tx);
    }

    for (const [, txs] of groups) {
      if (txs.length > 1) {
        duplicates.push({
          item: txs[0].item,
          amount: txs[0].amount,
          transactionIds: txs.map(t => t.id),
        });
      }
    }

    return duplicates;
  }

  /**
   * Encontra valores incomuns baseado no histórico
   */
  static async findUnusualAmounts(
    userId: string,
    recentTransactions: Transaction[]
  ): Promise<{ transactionId: string; description: string; severity: 'low' | 'medium' | 'high' }[]> {
    const { db } = await connectToDatabase();

    // Busca estatísticas históricas por categoria
    const threeMonthsAgo = new Date();
    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);

    const historicalTransactions = await db.collection<Transaction>('transactions')
      .find({
        userId,
        date: { $gte: threeMonthsAgo.toISOString() },
      })
      .toArray();

    // Calcula média e desvio por categoria
    const categoryStats = new Map<TransactionCategory, { mean: number; stdDev: number }>();
    const categoryAmounts = new Map<TransactionCategory, number[]>();

    for (const tx of historicalTransactions) {
      if (!categoryAmounts.has(tx.category)) {
        categoryAmounts.set(tx.category, []);
      }
      categoryAmounts.get(tx.category)!.push(tx.amount);
    }

    for (const [category, amounts] of categoryAmounts) {
      if (amounts.length < 5) continue; // Precisa de dados suficientes

      const mean = amounts.reduce((a, b) => a + b, 0) / amounts.length;
      const variance = amounts.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amounts.length;
      const stdDev = Math.sqrt(variance);

      categoryStats.set(category, { mean, stdDev });
    }

    const unusual: { transactionId: string; description: string; severity: 'low' | 'medium' | 'high' }[] = [];

    for (const tx of recentTransactions) {
      const stats = categoryStats.get(tx.category);
      if (!stats || stats.stdDev === 0) continue;

      const zScore = Math.abs((tx.amount - stats.mean) / stats.stdDev);

      if (zScore > 2) { // Mais de 2 desvios padrão
        const severity = zScore > 3 ? 'high' : 'medium';
        const diff = tx.amount > stats.mean ? 'acima' : 'abaixo';

        unusual.push({
          transactionId: tx.id,
          description: `Transação de R$ ${tx.amount.toFixed(2)} em "${tx.category}" está ${Math.round((zScore - 1) * 100)}% ${diff} do normal (média: R$ ${stats.mean.toFixed(2)})`,
          severity,
        });
      }
    }

    return unusual;
  }

  // ==================== BULK OPERATIONS ====================

  /**
   * Aplica uma regra a múltiplas transações existentes
   */
  static async applyRuleToTransactions(
    userId: string,
    ruleId: string,
    transactionIds: string[],
    updateCategory: boolean = true,
    updateWallet: boolean = false
  ): Promise<BulkActionResult> {
    const { db } = await connectToDatabase();

    // Busca a regra
    const rule = await db.collection<MerchantRule>('merchantRules').findOne({
      _id: new ObjectId(ruleId),
      userId,
    });

    if (!rule) {
      return { success: false, updatedCount: 0, failedCount: 0, errors: ['Regra não encontrada'] };
    }

    const updates: Record<string, any> = {};

    if (updateCategory) {
      updates.category = rule.defaultCategory;
      if (rule.defaultSubcategory) {
        updates.subcategory = rule.defaultSubcategory;
      }
    }

    if (updateWallet && rule.defaultWalletId) {
      updates.walletId = rule.defaultWalletId;
    }

    if (Object.keys(updates).length === 0) {
      return { success: false, updatedCount: 0, failedCount: 0, errors: ['Nenhum campo para atualizar'] };
    }

    try {
      const result = await db.collection('transactions').updateMany(
        {
          _id: { $in: transactionIds.map(id => new ObjectId(id)) },
          userId,
        },
        { $set: updates }
      );

      return {
        success: true,
        updatedCount: result.modifiedCount,
        failedCount: transactionIds.length - result.modifiedCount,
      };
    } catch (error) {
      return {
        success: false,
        updatedCount: 0,
        failedCount: transactionIds.length,
        errors: [(error as Error).message],
      };
    }
  }

  /**
   * Cria regra a partir de uma transação e aplica a transações similares
   */
  static async createRuleAndApplyToSimilar(
    userId: string,
    sourceTransaction: Transaction,
    applyToExisting: boolean = true
  ): Promise<{ rule: MerchantRule; appliedCount: number }> {
    const { db } = await connectToDatabase();

    const merchantName = sourceTransaction.establishment || sourceTransaction.item;

    // Cria a regra
    const rule = await this.createMerchantRule(userId, {
      merchantName,
      defaultCategory: sourceTransaction.category,
      defaultSubcategory: sourceTransaction.subcategory,
      defaultWalletId: sourceTransaction.walletId,
      defaultType: sourceTransaction.type as 'income' | 'expense',
      isAutoGenerated: false,
    });

    let appliedCount = 0;

    if (applyToExisting) {
      // Busca transações similares
      const normalized = this.normalizeText(merchantName);
      const keywords = this.extractKeywords(merchantName);

      const regexPatterns = keywords.map(kw => new RegExp(kw, 'i'));

      const similarTransactions = await db.collection<Transaction>('transactions')
        .find({
          userId,
          $or: [
            { item: { $in: regexPatterns } },
            { establishment: { $in: regexPatterns } },
          ],
          _id: { $ne: new ObjectId(sourceTransaction.id) },
        })
        .toArray();

      // Aplica a regra às transações similares
      if (similarTransactions.length > 0) {
        const result = await this.applyRuleToTransactions(
          userId,
          rule.id,
          similarTransactions.map(t => t._id.toString()),
          true,
          true
        );
        appliedCount = result.updatedCount;
      }
    }

    return { rule, appliedCount };
  }
}
